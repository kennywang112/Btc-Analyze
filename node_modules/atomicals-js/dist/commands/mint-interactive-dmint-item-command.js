"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MintInteractiveContainerDmintItemCommand = void 0;
const command_interface_1 = require("./command.interface");
const ecc = require("tiny-secp256k1");
const bitcoin = require('bitcoinjs-lib');
bitcoin.initEccLib(ecc);
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const address_helpers_1 = require("../utils/address-helpers");
const atomical_format_helpers_1 = require("../utils/atomical-format-helpers");
const get_by_container_command_1 = require("./get-by-container-command");
const tinysecp = require('tiny-secp256k1');
(0, bitcoinjs_lib_1.initEccLib)(tinysecp);
class MintInteractiveContainerDmintItemCommand {
    constructor(electrumApi, container, requestDmitem, address, fundingWIF, options) {
        this.electrumApi = electrumApi;
        this.container = container;
        this.requestDmitem = requestDmitem;
        this.address = address;
        this.fundingWIF = fundingWIF;
        this.options = options;
        this.options = (0, atomical_format_helpers_1.checkBaseRequestOptions)(this.options);
        this.container = this.container.startsWith('#') ? this.container.substring(1) : this.container;
    }
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                (0, address_helpers_1.detectAddressTypeToScripthash)(this.address);
                console.log("Initial mint address:", this.address);
            }
            catch (ex) {
                console.log('Error validating initial owner address');
                throw ex;
            }
            const getCmd = new get_by_container_command_1.GetByContainerCommand(this.electrumApi, this.container, command_interface_1.AtomicalsGetFetchType.LOCATION);
            const getResponse = yield getCmd.run();
            if (getResponse.success && getResponse.data.atomical_id) {
                return {
                    success: false,
                    msg: 'Error retrieving container parent atomical ' + this.container,
                    data: getResponse.data
                };
            }
            console.log('Proceeding to mint with the available container dmint minting rules (if available)...');
            const commandMintWithRules = new MintInteractiveContainerDmintItemCommand(this.electrumApi, this.requestDmitem, getResponse.data.atomical_id, this.address, this.fundingWIF, this.options);
            const commandMintWithRulesResponse = yield commandMintWithRules.run();
            if (commandMintWithRulesResponse.success) {
                return {
                    success: true,
                    data: commandMintWithRulesResponse.data
                };
            }
            return {
                success: false,
                data: commandMintWithRulesResponse.data
            };
        });
    }
}
exports.MintInteractiveContainerDmintItemCommand = MintInteractiveContainerDmintItemCommand;
